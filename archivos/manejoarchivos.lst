CCS PCM C Compiler, Version 5.005d, 1               11-jul-13 12:44
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\JavierC\archivos\manejoarchivos.lst

               ROM used:   374 words (5%)
                           Largest free fragment is 2048
               RAM used:   28 (8%) at main() level
                           35 (10%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   139
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.5
0018:  GOTO   01B
0019:  BTFSC  0B.2
001A:  GOTO   02C
001B:  MOVF   22,W
001C:  MOVWF  04
001D:  MOVF   23,W
001E:  MOVWF  77
001F:  MOVF   24,W
0020:  MOVWF  78
0021:  MOVF   25,W
0022:  MOVWF  79
0023:  MOVF   26,W
0024:  MOVWF  7A
0025:  MOVF   20,W
0026:  MOVWF  0A
0027:  SWAPF  21,W
0028:  MOVWF  03
0029:  SWAPF  7F,F
002A:  SWAPF  7F,W
002B:  RETFIE
002C:  BCF    0A.3
002D:  BCF    0A.4
002E:  GOTO   037
.................... #INCLUDE <16f887.h> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
002F:  BCF    0A.0
0030:  BCF    0A.1
0031:  BCF    0A.2
0032:  ADDWF  02,F
0033:  RETLW  28
0034:  RETLW  0C
0035:  RETLW  01
0036:  RETLW  06
....................  
.................... #list 
....................  
....................  
.................... #USE delay(clock=8000000) 
*
0050:  MOVLW  37
0051:  MOVWF  04
0052:  BCF    03.7
0053:  MOVF   00,W
0054:  BTFSC  03.2
0055:  GOTO   063
0056:  MOVLW  02
0057:  MOVWF  78
0058:  CLRF   77
0059:  DECFSZ 77,F
005A:  GOTO   059
005B:  DECFSZ 78,F
005C:  GOTO   058
005D:  MOVLW  97
005E:  MOVWF  77
005F:  DECFSZ 77,F
0060:  GOTO   05F
0061:  DECFSZ 00,F
0062:  GOTO   056
0063:  RETURN
.................... #INCLUDE "timers.c"  //doble comillas porque esta en la carpeta del proyecto 
....................  
.................... #ifndef __TIMERS__ //incluir siempre para evitar redefininciones. 
.................... #define __TIMERS__// el nombre __NOMBREDELHEADER__ es una convencion , usar siempre 
....................  
.................... #define N_TIMERS       10 
....................  
.................... #define _10ms          1 
.................... #define _20ms          2    
.................... #define _30ms          3   
.................... #define _40ms          4 
.................... #define _50ms          5 
.................... #define _60ms          6 
.................... #define _70ms          7 
.................... #define _80ms          8 
.................... #define _100ms         10 
.................... #define _500ms         50 
.................... #define _1s            100 
.................... #define _2s            200 
.................... #define _3s            300 
.................... #define _5s            500 
....................  
.................... int8 gtimers=N_TIMERS; 
.................... int8 atimer[N_TIMERS]; 
....................  
.................... void timers_init(void) 
.................... { 
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256); 
*
010E:  BSF    03.5
010F:  MOVF   01,W
0110:  ANDLW  C0
0111:  IORLW  07
0112:  MOVWF  01
....................    enable_interrupts(INT_TIMER0); 
0113:  BCF    03.5
0114:  BSF    0B.5
....................    set_timer0(178); 
0115:  MOVLW  B2
0116:  MOVWF  01
0117:  BCF    0A.3
0118:  BCF    0A.4
0119:  GOTO   15F (RETURN)
.................... } 
....................  
.................... void timers_set_time(int8 timer,int8 time) 
.................... { 
....................    atimer[timer]=time; 
011A:  MOVLW  28
011B:  ADDWF  36,W
011C:  MOVWF  04
011D:  BCF    03.7
011E:  MOVF   37,W
011F:  MOVWF  00
0120:  RETURN
.................... } 
....................  
.................... int8 timers_get_time(int8 timer) 
.................... { 
.................... return atimer[timer]; 
0121:  MOVLW  28
0122:  ADDWF  36,W
0123:  MOVWF  04
0124:  BCF    03.7
0125:  MOVF   00,W
0126:  MOVWF  78
0127:  BCF    0A.3
0128:  BCF    0A.4
0129:  GOTO   16A (RETURN)
.................... } 
....................    
....................   #int_timer0 
....................   void timers_isr(void) 
.................... { 
....................    set_timer0(178); 
*
0037:  MOVLW  B2
0038:  MOVWF  01
....................    while(gtimers) 
0039:  MOVF   27,F
003A:  BTFSC  03.2
003B:  GOTO   04A
....................    { 
....................    gtimers--; 
003C:  DECF   27,F
....................       if(atimer[gtimers]!=0) 
003D:  MOVLW  28
003E:  ADDWF  27,W
003F:  MOVWF  04
0040:  BCF    03.7
0041:  MOVF   00,F
0042:  BTFSC  03.2
0043:  GOTO   049
....................       { 
....................          atimer[gtimers]--;  
0044:  MOVLW  28
0045:  ADDWF  27,W
0046:  MOVWF  04
0047:  BCF    03.7
0048:  DECF   00,F
....................       } 
0049:  GOTO   039
....................    } 
....................    gtimers=N_TIMERS; 
004A:  MOVLW  0A
004B:  MOVWF  27
....................  
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... #INCLUDE "bsp.c" 
.................... #ifndef __BSP__ 
.................... #define __BSP__ 
.................... #INCLUDE <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
004C:  BCF    0B.2
004D:  BCF    0A.3
004E:  BCF    0A.4
004F:  GOTO   01B
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
015A:  BCF    03.6
015B:  CLRF   32
015C:  CLRF   33
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES INTRC_IO 
.................... #byte puertoA=0x05 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00D2:  MOVLW  0F
00D3:  BSF    03.5
00D4:  ANDWF  08,W
00D5:  IORLW  F0
00D6:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00D7:  BCF    03.5
00D8:  BSF    08.2
....................    delay_cycles(1); 
00D9:  NOP
....................    lcd_output_enable(1); 
00DA:  BSF    08.0
....................    delay_cycles(1); 
00DB:  NOP
....................    high = lcd_read_nibble(); 
00DC:  CALL   071
00DD:  MOVF   78,W
00DE:  MOVWF  3B
....................        
....................    lcd_output_enable(0); 
00DF:  BCF    08.0
....................    delay_cycles(1); 
00E0:  NOP
....................    lcd_output_enable(1); 
00E1:  BSF    08.0
....................    delay_us(1); 
00E2:  GOTO   0E3
....................    low = lcd_read_nibble(); 
00E3:  CALL   071
00E4:  MOVF   78,W
00E5:  MOVWF  3A
....................        
....................    lcd_output_enable(0); 
00E6:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00E7:  MOVLW  0F
00E8:  BSF    03.5
00E9:  ANDWF  08,W
00EA:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00EB:  BCF    03.5
00EC:  SWAPF  3B,W
00ED:  MOVWF  77
00EE:  MOVLW  F0
00EF:  ANDWF  77,F
00F0:  MOVF   77,W
00F1:  IORWF  3A,W
00F2:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0071:  MOVF   08,W
0072:  MOVWF  77
0073:  SWAPF  08,W
0074:  ANDLW  0F
0075:  MOVWF  78
....................   #endif 
0076:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0064:  SWAPF  3B,W
0065:  ANDLW  F0
0066:  MOVWF  77
0067:  MOVLW  0F
0068:  ANDWF  08,W
0069:  IORWF  77,W
006A:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
006B:  NOP
....................    lcd_output_enable(1); 
006C:  BSF    08.0
....................    delay_us(2); 
006D:  GOTO   06E
006E:  GOTO   06F
....................    lcd_output_enable(0); 
006F:  BCF    08.0
0070:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00CC:  BSF    03.5
00CD:  BCF    08.0
....................    lcd_rs_tris(); 
00CE:  BCF    08.1
....................    lcd_rw_tris(); 
00CF:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00D0:  BCF    03.5
00D1:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00F3:  MOVF   78,W
00F4:  MOVWF  3A
00F5:  BTFSC  3A.7
00F6:  GOTO   0D2
....................    lcd_output_rs(address); 
00F7:  BTFSS  38.0
00F8:  BCF    08.1
00F9:  BTFSC  38.0
00FA:  BSF    08.1
....................    delay_cycles(1); 
00FB:  NOP
....................    lcd_output_rw(0); 
00FC:  BCF    08.2
....................    delay_cycles(1); 
00FD:  NOP
....................    lcd_output_enable(0); 
00FE:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
00FF:  SWAPF  39,W
0100:  MOVWF  3A
0101:  MOVLW  0F
0102:  ANDWF  3A,F
0103:  MOVF   3A,W
0104:  MOVWF  3B
0105:  CALL   064
....................    lcd_send_nibble(n & 0xf); 
0106:  MOVF   39,W
0107:  ANDLW  0F
0108:  MOVWF  3A
0109:  MOVWF  3B
010A:  CALL   064
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
*
009F:  MOVLW  0F
00A0:  BSF    03.5
00A1:  ANDWF  08,W
00A2:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
00A3:  BCF    08.0
....................    lcd_rs_tris(); 
00A4:  BCF    08.1
....................    lcd_rw_tris(); 
00A5:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
00A6:  BCF    03.5
00A7:  BCF    08.1
....................    lcd_output_rw(0); 
00A8:  BCF    08.2
....................    lcd_output_enable(0); 
00A9:  BCF    08.0
....................      
....................    delay_ms(15); 
00AA:  MOVLW  0F
00AB:  MOVWF  37
00AC:  CALL   050
....................    for(i=1;i<=3;++i) 
00AD:  MOVLW  01
00AE:  MOVWF  36
00AF:  MOVF   36,W
00B0:  SUBLW  03
00B1:  BTFSS  03.0
00B2:  GOTO   0BB
....................    { 
....................        lcd_send_nibble(3); 
00B3:  MOVLW  03
00B4:  MOVWF  3B
00B5:  CALL   064
....................        delay_ms(5); 
00B6:  MOVLW  05
00B7:  MOVWF  37
00B8:  CALL   050
00B9:  INCF   36,F
00BA:  GOTO   0AF
....................    } 
....................     
....................    lcd_send_nibble(2); 
00BB:  MOVLW  02
00BC:  MOVWF  3B
00BD:  CALL   064
....................    delay_ms(5); 
00BE:  MOVLW  05
00BF:  MOVWF  37
00C0:  CALL   050
....................    for(i=0;i<=3;++i) 
00C1:  CLRF   36
00C2:  MOVF   36,W
00C3:  SUBLW  03
00C4:  BTFSS  03.0
00C5:  GOTO   10D
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00C6:  MOVF   36,W
00C7:  CALL   02F
00C8:  MOVWF  37
00C9:  CLRF   38
00CA:  MOVF   37,W
00CB:  MOVWF  39
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
*
010B:  INCF   36,F
010C:  GOTO   0C2
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
....................       address=LCD_LINE_TWO; 
....................    else 
....................       address=0; 
....................       
....................    address+=x-1; 
....................    lcd_send_byte(0,0x80|address); 
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
....................                      delay_ms(2); 
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
....................      #endif 
....................    } 
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................    void bsp_init(void) 
....................    { 
....................       set_tris_c(0xFF); 
*
0077:  MOVLW  FF
0078:  BSF    03.5
0079:  MOVWF  07
007A:  BCF    03.5
007B:  MOVWF  34
....................       set_tris_e(0xFF); 
007C:  BSF    03.5
007D:  BSF    09.0
007E:  BSF    09.1
007F:  BSF    09.2
0080:  BSF    09.3
....................       set_tris_a(0); 
0081:  MOVLW  00
0082:  MOVWF  05
....................       output_a(0); 
0083:  CLRF   05
0084:  BCF    03.5
0085:  CLRF   05
....................       SETUP_ADC_PORTS(sAN5); 
0086:  BSF    03.5
0087:  BSF    03.6
0088:  MOVF   09,W
0089:  ANDLW  C0
008A:  MOVWF  09
008B:  BCF    03.6
008C:  BCF    1F.4
008D:  BCF    1F.5
008E:  MOVLW  20
008F:  BSF    03.6
0090:  MOVWF  08
....................       SET_ADC_CHANNEL(5); 
0091:  MOVLW  14
0092:  MOVWF  78
0093:  BCF    03.5
0094:  BCF    03.6
0095:  MOVF   1F,W
0096:  ANDLW  C3
0097:  IORWF  78,W
0098:  MOVWF  1F
....................       setup_adc(ADC_CLOCK_DIV_32); 
0099:  BCF    1F.6
009A:  BSF    1F.7
009B:  BSF    03.5
009C:  BCF    1F.7
009D:  BCF    03.5
009E:  BSF    1F.0
....................       lcd_init(); 
*
010D:  RETURN
....................        
....................    } 
....................  
....................    void bsp_leds(int8 val) 
....................    { 
....................       output_a(val); 
....................    } 
....................     
....................    int8 bsp_lee_sw(void) 
....................    { 
....................       int var; 
....................       var = input(PIN_C0); 
....................       var += (input(PIN_C1)*2); 
....................       var += (input(PIN_C2)*4); 
....................       var += (input(PIN_C3)*8); 
....................       var += (input(PIN_C4)*16); 
....................       var += (input(PIN_C5)*32); 
....................       var += (input(PIN_E1)*64); 
....................       var += (input(PIN_E2)*128); 
....................       return var; 
....................    } 
....................  
....................    void bsp_led_on(int8 led) 
....................    { 
....................    puertoA=puertoA | (1<<led); 
....................    } 
....................     
....................    void bsp_led_off(int8 led) 
....................    { 
....................    puertoA=puertoA & (~(1<<led)); 
....................    } 
....................     
....................    void bsp_led_toggle(int8 led) 
....................    { 
....................    puertoA=puertoA ^ (1<<led); 
*
012A:  MOVLW  01
012B:  MOVWF  77
012C:  MOVF   36,W
012D:  MOVWF  78
012E:  BTFSC  03.2
012F:  GOTO   134
0130:  BCF    03.0
0131:  RLF    77,F
0132:  DECFSZ 78,F
0133:  GOTO   130
0134:  MOVF   77,W
0135:  XORWF  05,F
0136:  BCF    0A.3
0137:  BCF    0A.4
0138:  GOTO   174 (RETURN)
....................    } 
....................     
....................    bsp_lee_unsw(int8 sw) 
....................    {  int8 valor; 
....................       valor = bsp_lee_sw(); 
....................       return (valor & (1<<sw) != 0); 
....................    } 
....................     
....................    int8 bsp_lee_pot(void) 
....................    { 
....................    int8 x; 
....................     
....................    x = read_adc(); 
....................    return x; 
....................    } 
....................  
.................... #endif 
....................  
....................  
.................... void main() 
0139:  MOVLW  0A
013A:  MOVWF  27
013B:  BSF    03.5
013C:  BSF    03.6
013D:  BCF    07.3
013E:  MOVLW  0C
013F:  BCF    03.6
0140:  MOVWF  19
0141:  MOVLW  A2
0142:  MOVWF  18
0143:  MOVLW  90
0144:  BCF    03.5
0145:  MOVWF  18
0146:  MOVLW  FF
0147:  MOVWF  34
0148:  BSF    03.5
0149:  BSF    03.6
014A:  MOVF   09,W
014B:  ANDLW  C0
014C:  MOVWF  09
014D:  BCF    03.6
014E:  BCF    1F.4
014F:  BCF    1F.5
0150:  MOVLW  00
0151:  BSF    03.6
0152:  MOVWF  08
0153:  BCF    03.5
0154:  CLRF   07
0155:  CLRF   08
0156:  CLRF   09
0157:  BCF    03.7
0158:  MOVLW  1F
0159:  ANDWF  03,F
.................... {  int x; 
....................    bsp_init(); 
*
015D:  CALL   077
....................    timers_init(); 
015E:  GOTO   10E
....................    enable_interrupts(GLOBAL); 
015F:  MOVLW  C0
0160:  IORWF  0B,F
....................    bsp_init(); 
0161:  CALL   077
....................    timers_set_time(1,_100ms); 
0162:  MOVLW  01
0163:  MOVWF  36
0164:  MOVLW  0A
0165:  MOVWF  37
0166:  CALL   11A
....................     
....................    while(TRUE) 
....................    { 
....................     
....................    if (timers_get_time(1)==0) 
0167:  MOVLW  01
0168:  MOVWF  36
0169:  GOTO   121
016A:  MOVF   78,F
016B:  BTFSS  03.2
016C:  GOTO   174
....................    { 
....................     timers_set_time(1,_100ms); 
016D:  MOVLW  01
016E:  MOVWF  36
016F:  MOVLW  0A
0170:  MOVWF  37
0171:  CALL   11A
....................     bsp_led_toggle(0);   
0172:  CLRF   36
0173:  GOTO   12A
....................    } 
0174:  GOTO   167
....................     
....................    
....................    } 
....................  
.................... } 
0175:  SLEEP

Configuration Fuses:
   Word  1: 2FE4   INTRC_IO NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
